#include<iostream>
#include<string>
#include<vector>
#include"Rational.h"
#include"Stack.h"
#include"reverse_polish_notation.h"
using namespace std;

Rational extract(string& str) {
	int rez = 0, idx = 0, m, n;
	if (str[idx] != '0')
		while (int(str[idx]) <= 57 and int(str[idx]) >= 48 and idx < str.size()) {
			rez = rez * 10 + int(str[idx]) - 48;
			idx++;
		}
	else
		throw exception("Некорректный ввод выражения");
	m = rez;
	if (str[idx] == '|') {
		idx++;
		rez = 0;
		if (str[idx] != '0')
			while (int(str[idx]) <= 57 and int(str[idx]) >= 48 and idx < str.size()) {
				rez = rez * 10 + int(str[idx]) - 48;
				idx++;
			}
		else
			throw exception("Некорректный ввод выражения");
		n = rez;
	
	}
	else if (str[idx] == ' ') {
		n = 1;
	}
	else
		throw exception("Некорректный ввод выражения");

	str.erase(str.begin(), str.begin() + idx + 1);
	return Rational::Rational(m, n);
}

int main() {
	string OPZ;
	Stack<Rational> st;
	Rational temp1, temp2, result;
	char operation;
	// (a+b)*(c-d)/(e^f)
	//a b +c d -*e f ^/
	// (5|6+7|10)*(17|23-2|23)/(4|7^3|1)

	string expression;
	cin >> expression;
	vector<char> operators{ '-','+','/','*','^' };
	vector<int> priorities{ 0,0,1,1,2 };
	OPZ = reverse_polish_notation(expression, operators, priorities);
	cout << "Reverse Polish Notation: " << OPZ << endl;

	while (OPZ.size() != 0) {
		if (OPZ[0] != '+' and OPZ[0] != '-' and OPZ[0] != '*' and OPZ[0] != '/' and OPZ[0] != '^')
			st.push(extract(OPZ));
		else {
			switch (OPZ[0])
			{
			case '!':
				// унарный минус
				break;
			case '+':
				temp2 = st.look_top();
				st.pop();
				temp1 = st.look_top();
				st.pop();
				result = temp1 + temp2;
				st.push(result);
				break;
			case '-':
				temp2 = st.look_top();
				st.pop();
				temp1 = st.look_top();
				st.pop();
				result = temp1 - temp2;
				st.push(result);
				break;
			case '*':
				temp2 = st.look_top();
				st.pop();
				temp1 = st.look_top();
				st.pop();
				result = temp1 * temp2;
				st.push(result);
				break;
			case '/':
				temp2 = st.look_top();
				st.pop();
				temp1 = st.look_top();
				st.pop();
				result = temp1 / temp2;
				st.push(result);
				break;
			case '^':
				temp2 = st.look_top();
				st.pop();
				temp1 = st.look_top();
				st.pop();
				result = (temp1 ^ temp2);
				st.push(result);
				break;
			}
			OPZ.erase(OPZ.begin(), OPZ.begin() + 1);
		}
	}

	cout << "result = " << st.look_top() << endl;
	system("pause");
	return 0;
}
